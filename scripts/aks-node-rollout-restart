#!/bin/bash
export THIS_SCRIPT_DIRECTORY=$(dirname $0)
export PATH=${PATH}:${THIS_SCRIPT_DIRECTORY}
export EXECUTION_ID="$(uuidgen)"
export CACHE_DIRECTORY="${THIS_SCRIPT_DIRECTORY}/.cache/${EXECUTION_ID}"

mkdir -p "${CACHE_DIRECTORY}"

show_usage() {
  cat <<EOF

  ./aks-node-rollout-restart \\
    --cluster-name aks-cluster-example \\
    --resource-group aks-cluster-example \\
    --name aks-systempool-37832835-vmss000000 \\
    --dry-run

  ./aks-node-rollout-restart \\
    --cluster-name aks-cluster-example \\
    --resource-group aks-cluster-example \\
    --nodes 1 \\
    --dry-run

EOF
}

while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do
case $1 in
  -h | --help )
    show_usage
    exit
    ;;
  -cn | --cluster-name )
    shift; AKS_CLUSTER_NAME=$1
    ;;
  -rg | --resource-group )
    shift; AKS_CLUSTER_RESOURCE_GROUP_NAME=$1
    ;;
  -n | --name )
    shift; AKS_NODE_NAME=$1
    ;;
  -nc | --nodes )
    shift; AKS_NODE_COUNT=$1
    ;;
  --dry-run )
    shift; DRY_RUN="y"
    ;;
esac; shift; done

if [[ "$1" == '--' ]]; then shift; fi

DRY_RUN=${DRY_RUN-n}

if [ -z "${AKS_CLUSTER_NAME}"                ] || \
   [ -z "${AKS_CLUSTER_RESOURCE_GROUP_NAME}" ] || \
   [ -z "${AKS_NODE_NAME}${AKS_NODE_COUNT}"  ]; then
  show_usage
  exit 1
fi

if ! which kubectl &> /dev/null; then
  az aks install-cli
fi

KUBECTL_CONFIG_CONTEXT_EXISTS=$(kubectl config get-contexts | grep ${AKS_CLUSTER_NAME} | wc -l)

if [ "${KUBECTL_CONFIG_CONTEXT_EXISTS}" == "0" ]; then
  az aks get-credentials \
    --name ${AKS_CLUSTER_NAME?} \
    --resource-group ${AKS_CLUSTER_RESOURCE_GROUP_NAME?} \
    --overwrite-existing \
    --admin
fi

deployment_file() {
  DEPLOYMENT_NAMESPACE=$1
  DEPLOYMENT_NAME=$2

  mkdir -p "${CACHE_DIRECTORY}/${DEPLOYMENT_NAMESPACE}"

  FILE_NAME="${CACHE_DIRECTORY}/${DEPLOYMENT_NAMESPACE}/${DEPLOYMENT_NAME}"

  echo "${FILE_NAME}"
}

function collect_deployments_info() {
  kubectl get deployments \
    --all-namespaces \
    --no-headers \
    --output wide \
  | while read LINE; do
    DEPLOYMENT_NAMESPACE=$(awk '{ print $1 }' <<< "${LINE}")
    DEPLOYMENT_NAME=$(     awk '{ print $2 }' <<< "${LINE}")
    DEPLOYMENT_SELECTORS=$(awk '{ print $9 }' <<< "${LINE}")

    kubectl get pod \
      --output wide \
      --no-headers \
      --namespace "${DEPLOYMENT_NAMESPACE}" \
      --selector  "${DEPLOYMENT_SELECTORS}" \
      | awk '{ print $1, $7 }' \
      | while read POD_LINE; do
          POD_NAME=$(     awk '{ print $1 }' <<< "${POD_LINE}")
          POD_NODE_NAME=$(awk '{ print $7 }' <<< "${POD_LINE}")

          FILE_NAME=$(deployment_file "${DEPLOYMENT_NAMESPACE}" "${DEPLOYMENT_NAME}")
          echo "${POD_NODE_NAME} ${POD_NAME}" >> "${FILE_NAME}"
          echo "${POD_NODE_NAME} :: ${DEPLOYMENT_NAMESPACE} :: ${DEPLOYMENT_NAME} :: ${POD_NAME}"
    done
  done
}

node_cordon() {
  NODE_NAME=$1

  if [ "${DRY_RUN}" != "y" ]; then
    kubectl cordon ${NODE_NAME}
  else
    echo "${NODE_NAME} :: cordoned"
  fi
}

node_list() {
  NODE_NAME=$1

  kubectl get nodes \
    --output jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' \
  | grep "${NODE_NAME}"
}

node_read() {
  while read -r NODE_NAME; do
    node_cordon ${NODE_NAME?}
  done
}

collect_deployments_info

exit 0

if [ -n "${AKS_NODE_NAME}" ]; then
  node_list ${AKS_NODE_NAME} \
  | node_read
else
  node_list | head -${AKS_NODE_COUNT} \
  | node_read
fi
